from __future__ import annotations

import sys

import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from pandas import unique
from scipy.cluster.hierarchy import dendrogram

from selectzyme.backend.customizations import set_columns_of_interest
from selectzyme.backend.utils import run_time


@run_time
def create_dendrogram(Z, df, legend_attribute: str = "cluster"):
    """
    Creates an interactive dendrogram plot using Plotly.
    Parameters:
    -----------
    Z : array-like
        The linkage matrix generated by hierarchical clustering.
    df : pandas.DataFrame
        The dataframe containing data corresponding to the dendrogram leaves.
    legend_attribute : str, optional
        The column name in the dataframe used to color the markers in the plot.
        Default is "cluster".
    Returns:
    --------
    plotly.graph_objects.Figure
        A Plotly figure object containing the dendrogram plot.
    Notes:
    ------
    - The dendrogram lines are hidden by default for datasets with more than 10,000 rows.
    - Markers are placed at the left branch of each cluster with a slight offset to avoid hover interference.
    - The dataframe is reordered to match the dendrogram leaves, and hover text is generated based on selected columns.
    - The plot is saved as an HTML file named 'results/slc.html'.
    """
    sys.setrecursionlimit(
        max(df.shape[0], 10000)
    )  # fixed: RecursionError: maximum recursion depth exceeded
    P = dendrogram(Z, no_plot=False, distance_sort=False)
    
    icoord = np.array(P["icoord"])  # ordered after 'leaves' and not Z!
    dcoord = np.array(P["dcoord"])
    leaves = P["leaves"]  # Indices of df rows corresponding to leaves

    layout = go.Layout(
        xaxis_title="Variant",
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis_title="Distance",
        showlegend=True,
    )
    fig = go.Figure(layout=layout)

    line_visibility = "legendonly" if df.shape[0] > 10000 else None

    # Pre-calculate traces
    x_lines = _insert_separator(icoord)
    y_lines = _insert_separator(dcoord)
    # Add lines trace
    fig.add_trace(
        go.Scattergl(
            x=x_lines,
            y=y_lines,
            mode="lines",
            # line=dict(color=line_colors),  # not possible to pass list so branch color not specifically changable
            hoverinfo="none",
            visible=line_visibility,  # dont load line traces by default for large datasets
            name="Dendrogram lines"
        )
    )

    # Pre-calculate markers
    marker_x = icoord[:, 0]  # always use left branch to place marker
    marker_y = (
        dcoord[:, 1] - 0.001
    )  # if set [0] or [1], hover breaks idk on this unexpected behaviour. 0.001 offset to avoid interference

    # Order df to represent 'leaves' correctly
    df_copy = df.iloc[leaves].copy()

    # set color mapping for markerÂ´s legend_attribute
    color_mapping = _value_to_color(
        df[legend_attribute]
    )  # use df for same order of legend entries and same color mapping
    marker_colors = df_copy[legend_attribute].map(color_mapping).to_numpy()

    # set markers
    columns_of_interest = set_columns_of_interest(df_copy.columns)
    for attribute in df_copy[legend_attribute].unique():
        mask = df_copy[legend_attribute] == attribute
        subset = df_copy[mask]

        fig.add_trace(go.Scattergl(
            x=marker_x[mask[:marker_x.shape[0]]],
            y=marker_y[mask[:marker_y.shape[0]]],
            mode='markers',
            marker=dict(
                color=marker_colors[mask[:marker_colors.shape[0]]],
                symbol=subset['marker_symbol'],
                size=subset['marker_size'],
                opacity=0.8
            ),
            customdata=subset['accession'],
            text=subset.apply(lambda row: '<br>'.join([f'{col}: {row[col]}' for col in columns_of_interest]), axis=1),
            hoverinfo="text",
            showlegend=True,
            name=str(attribute),
            legendgroup=str(attribute)  # group attributes in legend
        ))

    fig.update_layout(
        showlegend=True,
        legend=dict(
            title=dict(text=legend_attribute),
            traceorder='reversed'
        ))
    
    # # Debugging: Save the matplotlib dendrogram to a file for comparison
    # import matplotlib.pyplot as plt

    # fig_, ax = plt.subplots(figsize=(12, 6))
    # dendro = dendrogram(Z, labels=df['accession'].tolist(), ax=ax)  # labels are automatically in correct leaves equivalent ordering 
    # plt.xlabel("Accession")
    # plt.ylabel("Distance")
    # plt.tight_layout()
    # plt.savefig("slc_dendrogram_matplotlib.png")
    # plt.close()

    return fig


def _value_to_color(values) -> dict:
    """
    Maps a list of values to a continuous color scale.

    Parameters:
    -----------
    values : array-like
        Values to map to a color scale.
    Returns:
    --------
        A dictionary mapping unique values to corresponding colors in the colormap.
    """
    unique_values = unique(values)

    # Use Plotly's default qualitative color sequence
    default_colors = px.colors.qualitative.Plotly
    n_colors = len(default_colors)

    return {val: default_colors[i % n_colors] for i, val in enumerate(unique_values)}


def _insert_separator(arrays: np.ndarray) -> np.ndarray:
    # Append NaN to each array and concatenate
    return np.hstack([np.append(a, np.nan) for a in arrays])
