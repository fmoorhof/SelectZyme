from __future__ import annotations

import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from pandas import unique
from scipy.cluster.hierarchy import dendrogram

from selectzyme.customizations import set_columns_of_interest
from selectzyme.utils import run_time


@run_time
def create_dendrogram(Z, df, legend_attribute: str = "cluster"):
    """
    Creates an interactive dendrogram plot using Plotly.
    Parameters:
    -----------
    Z : array-like
        The linkage matrix generated by hierarchical clustering.
    df : pandas.DataFrame
        The dataframe containing data corresponding to the dendrogram leaves.
    legend_attribute : str, optional
        The column name in the dataframe used to color the markers in the plot.
        Default is "cluster".
    Returns:
    --------
    plotly.graph_objects.Figure
        A Plotly figure object containing the dendrogram plot.
    Notes:
    ------
    - The dendrogram lines are hidden by default for datasets with more than 10,000 rows.
    - Markers are placed at the left branch of each cluster with a slight offset to avoid hover interference.
    - The dataframe is reordered to match the dendrogram leaves, and hover text is generated based on selected columns.
    - The plot is saved as an HTML file named 'results/slc.html'.
    """
    P = dendrogram(Z, no_plot=True, distance_sort="ascending")
    icoord = np.array(P["icoord"])  # ordered after 'leaves' and not Z!
    dcoord = np.array(P["dcoord"])
    leaves = P["leaves"]  # Indices of df rows corresponding to leaves

    layout = go.Layout(
        xaxis_title="Variant",
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis_title="Distance",
        showlegend=True,
    )
    fig = go.Figure(layout=layout)

    line_visibility = "legendonly" if df.shape[0] > 10000 else None

    # Pre-calculate traces
    x_lines = _insert_separator(icoord)
    y_lines = _insert_separator(dcoord)
    # Add lines trace
    fig.add_trace(
        go.Scattergl(
            x=x_lines,
            y=y_lines,
            mode="lines",
            # line=dict(color=line_colors),  # not possible to pass list so branch color not specifically changable
            hoverinfo="none",
            visible=line_visibility,  # dont load line traces by default for large datasets
            name="Dendrogram lines"
        )
    )

    # Pre-calculate markers
    marker_x = icoord[:, 0]  # always use left branch to place marker
    marker_y = (
        dcoord[:, 1] - 0.001
    )  # if set [0] or [1], hover breaks idk on this unexpected behaviour. 0.001 offset to avoid interference

    # Order df to represent 'leaves' correctly
    df_copy = df.iloc[leaves].copy()

    # set color mapping for markerÂ´s legend_attribute
    color_mapping = _value_to_color(
        df[legend_attribute]
    )  # use df for same order of legend entries and same color mapping
    marker_colors = df_copy[legend_attribute].map(color_mapping).to_numpy()

    # set markers
    columns_of_interest = set_columns_of_interest(df_copy.columns)
    for attribute in df_copy[legend_attribute].unique():
        mask = df_copy[legend_attribute] == attribute
        subset = df_copy[mask]

        fig.add_trace(go.Scattergl(
            x=marker_x[mask[:marker_x.shape[0]]],
            y=marker_y[mask[:marker_y.shape[0]]],
            mode='markers',
            marker=dict(
                color=marker_colors[mask[:marker_colors.shape[0]]],
                symbol=subset['marker_symbol'],
                size=subset['marker_size'],
                opacity=0.8
            ),
            customdata=subset['accession'],
            text=subset.apply(lambda row: '<br>'.join([f'{col}: {row[col]}' for col in columns_of_interest]), axis=1),
            hoverinfo="text",
            showlegend=True,
            name=str(attribute),
            legendgroup=str(attribute)  # group attributes in legend
        ))

    fig.update_layout(
        showlegend=True,
        legend=dict(
            title=dict(text=legend_attribute),
            traceorder='reversed'
        ))

    fig.write_html('results/slc.html')
    return fig


def _value_to_color(values) -> dict:
    """
    Maps a list of values to a continuous color scale.

    Parameters:
    -----------
    values : array-like
        Values to map to a color scale.
    Returns:
    --------
        A dictionary mapping unique values to corresponding colors in the colormap.
    """
    unique_values = unique(values)

    # Use Plotly's default qualitative color sequence
    default_colors = px.colors.qualitative.Plotly
    n_colors = len(default_colors)

    return {val: default_colors[i % n_colors] for i, val in enumerate(unique_values)}


def _insert_separator(arrays: np.ndarray) -> np.ndarray:
    # Append NaN to each array and concatenate
    return np.hstack([np.append(a, np.nan) for a in arrays])


if __name__ == "__main__":
    import hdbscan
    import numpy as np
    import pandas as pd
    from sklearn.datasets import make_blobs

    np.random.seed(42)
    sample_size = 11  # too big samples cause RecursionError but strangely not for my real datasets
    df = pd.DataFrame(
        {
            "x": np.random.randn(sample_size),
            "y": np.random.randn(sample_size),
            "accession": np.arange(sample_size),
            "cluster": np.random.choice([-1, 1, 3], sample_size),
            "selected": np.random.choice([False, True], sample_size),
            "marker_symbol": np.random.choice(
                ["circle", "square", "diamond", "triangle-up"], sample_size
            ),
            "marker_size": np.random.randint(10, sample_size, sample_size),
        }
    )
    data, _ = make_blobs(
        n_samples=sample_size, n_features=2, centers=3, cluster_std=0.8, random_state=42
    )

    clusterer = hdbscan.HDBSCAN(min_cluster_size=2, gen_min_span_tree=True)
    clusterer.fit(data)

    hover_text = [
        "<br>".join(f"{col}: {df[col][i]}" for col in df.columns)
        for i in range(len(df))
    ]

    fig = create_dendrogram(
        Z=clusterer.single_linkage_tree_._linkage, df=df, hovertext=hover_text
    )
    fig.show()
